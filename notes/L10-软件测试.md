---
attachments: [Clipboard_2021-06-14-20-40-54.png, Clipboard_2021-06-14-20-41-38.png, Clipboard_2021-06-14-21-13-24.png, Clipboard_2021-06-14-21-17-51.png, Clipboard_2021-06-14-21-28-02.png, Clipboard_2021-06-14-21-43-06.png, Clipboard_2021-06-14-21-55-14.png, Clipboard_2021-06-14-21-56-03.png, Clipboard_2021-06-14-21-59-29.png, Clipboard_2021-06-14-22-02-28.png]
tags: [大二/CS335软件工程与软件过程]
title: L10-软件测试
created: '2021-06-14T12:16:01.428Z'
modified: '2021-09-27T06:13:57.837Z'
---

# L10-软件测试
## 介绍
### 什么是软件测试
- **为什么要进行软件测试**
> 软件测试的目的是**一个程序做它想做的事，并在它投入使用之前发现程序缺陷**
- **如何进行软件测试**
> 当您测试软件时，您**使用人工数据执行程序**
- **通过软件测试，我们可以获得什么?**
> 您可以检查测试运行的结果，以查找有关程序**非功能属性的错误、异常或信息**

测试是更一般的**软件验证和确认过程的一部分**

### 软件测试的目标
- 向开发人员和客户**演示软件满足其需求**
>+ 对于定制软件
需求文档中的每个需求都应该至少有一个测试。
>+ 对于通用软件
应该对所有的系统特性进行测试，加上这些特性的组合，这些特性将合并到产品发布中
- **发现软件**不正确、不受欢迎的行为或不符合其规范**的糟糕情况**
> 缺陷测试关注的是根除不需要的系统行为，比如系统崩溃、与其他系统的不需要的交互、不正确的计算和数据损坏

### 测试过程的目标
#### 验证测试(Validation Testing)
- 向开发人员和系统客户演示该软件满足其需求
- **成功的测试表明该系统按预期运行**
#### 缺陷测试(Defect Testing)
- 在软件的行为不正确或不符合其规范的地方**发现错误或缺陷**
- **成功的测试是使系统执行不正确**，从而暴露系统中的缺陷的测试

![程序测试中的输入-输出模型](@attachment/Clipboard_2021-06-14-20-40-54.png)

### 验证与确认
#### 验证(Verification)
- 关注“我们构建的产品是正确的吗?”的问题
> Are we building the product right?
- 软件应符合其规格说明
#### 确认(Validation)
- 关注“我们是否构建了正确的产品?”的问题
> "Are we building the right product?”
- 软件应该做用户真正需要的

经过这两个测试(V & V过程)，建立起对系统“符合目的”的信心

### 检测与测试
#### 软件检查(Software Inspections)
- 对静态系统表示进行分析以发现问题**(静态验证)**
- 可以通过基于工具的文档和代码分析进行补充
#### 软件测试(Software Testing)
- 有关实践和观察产品行为**(动态验证)**
- 系统使用测试数据执行，并观察其操作行为
#### 区别
检查和测试是互补的，而不是对立的验证技术
二者都应该在V & V过程中使用
- 软件检查可以检查是否符合规格，但不符合客户的实际要求
- 软件检查不能检查非功能特征，如性能、可用性等

![软件测试流程模型](@attachment/Clipboard_2021-06-14-20-41-38.png)

### 测试的阶段
- 开发测试
在开发过程中测试系统以发现bug和缺陷
- 发布测试
由单独的测试团队在系统发布给用户之前测试系统的完整版本
- 用户测试
系统的用户或潜在用户在他们自己的环境中测试系统

## 测试(Testing)与捉虫(Debugging)
缺陷测试和捉虫是不同的过程: 
> 缺陷测试涉及到确认错误的存在
>+ 比较输入和输出
>+ 程序为什么不工作(废话因为有bug啊————
>+ 我要怎么打破我的程序(你需要一把锤子
> 
> 捉虫涉及到定位和修复这些错误
>+ 研究是什么东西导致了错误发生
>+ 为什么代码不工作
>+ 我要如何修复我的程序
>+ 目标是搞出一个没有bug的美好程序
>+ 有系统地寻找bug

捉虫涉及到制定一个关于程序行为的假设，然后测试这些假设以找到系统错误

### 测试
#### 进行测试之前...
首先你需要确定你的代码能够运行，它不是意大利面怪
- 不要有奇奇怪怪的语法错误
- 不要有奇奇怪怪的静态语义错误
其次你需要有一组预期的测试结果
- 一组输入
- 对输入组中的每个输入，都有一个对应的预期输出

### 捉虫
#### 捉虫之道
以下方法都可以通过调试工具(如调试编译器、动态调试辅助)加以补充
- 暴力破解代码，直到bug被发现
- 回溯
比较适合小程序，回到没bug的上一版本，并进行对比
- 原因消除
假设是什么导致的错误，并输入测试数据来检查

#### 捉虫时可能遇到的问题
- 观察到的bug及其原因可能在地理上是分开的
- 观察到的bug可能随着另一个问题的修复而消失
- bug的原因可能是难以追踪的人为错误
- bug的原因可能是每个人都相信的假设
- 观察到的bug可能是间歇性的，因为系统或编译错误

#### debug有的时候要人命
- 重新考虑假设
操作系统改变了吗?硬盘满了吗?这是闰年吗?
- 开始为您的系统编制文档
> 提供一个全新的角度，并突出显示困惑的地方
确保注释和规范描述了代码
- 寻求外界的帮助
个人的能力是有限的，我们每个人都会有盲点

### 我们需要做什么、不需要做什么？
![](@attachment/Clipboard_2021-06-14-21-13-24.png)

## 软件质量
软件开发伴随着风险。现代软件通常十分复杂，伴随着几千行的代码。用户需求可能十分模糊，此外ddl和预算也很搞开发团队心态。诸多因素可能导致软件质量下降，这对开发团队、公司名誉的损害是巨大的
### 如何评价软件质量
根据ISO91261软件工程标准，衡量一个软件的质量主要从以下六个方面入手：
![](@attachment/Clipboard_2021-06-14-21-17-51.png)

即：
- 功能性
适用性、准确性、互操作性、合规性、安全性
- 可靠性
成熟、容错、可恢复性
- 可用性
易懂、易学性、可操作性
- 效率
时间行为，资源行为
- 可维护性
可分析性，易变性，稳定性，可测试性
- 可移植性
适应性，可安装性，一致性，可更换性

### 反映软件质量糟糕的一面
主要有三个要素：错误、故障和失败
- 错误(Error)
> 错误指的是软件开发人员所犯的错误。它们**存在于程序员的头脑中**，并可能导致软件中的一个或多个错误

- 故障(Fault)
> 故障**由源代码中的错误代码组成**，可能是一个或多个错误的产物。错误可能导致程序执行过程中的失败
> 故障类型
>+ 算法类故障(占将近50%)
>> 算法故障是指当软件的某个单元在指定的算法下不能产生对应于给定输入的输出时发生的故障
>+ 语法类故障
>+ 文档类故障
>+ 应力或过载类故障
>+ 容量和边界类故障
>+ 计算和精度类故障(占将近50%)
>> 当使用所选公式计算的结果不符合预期的精度或精度时，计算和精度故障就会发生
>+ 吞吐量或性能类故障
>+ 恢复类故障
>+ 定时或协调类故障
>+ 标准和步骤类故障

- 失败(Failure)
> 失败是**故障的症状**，由软件的不正确或不规范行为组成。错误可能一直隐藏着，直到满足了一组特定的条件，这些条件表明它们是软件执行中的一个失败
几种级别的失败如下：
>+ **导致系统崩溃**，恢复时间很长;或者故障会导致功能和数据的丢失，没有任何变通方法
>+ **导致功能或数据的丢失**，但是有手动的变通方法来临时完成这些任务
>+ **导致部分功能或数据丢失**，用户可以用少量变通方法完成大部分任务
>+ **导致表面上和轻微的不便**，所有用户任务仍然可以完成

#### 从故障到失败
首先，程序员在敲代码的时候写错了什么东西，导致了故障产生(Fault)
当程序执行，故障开始传染
之后，传染进一步升级，并影响到程序本身
最后，传染造成了失败。不过需要注意的是，**并不是每个传染最终都会造成失败，也不是每个故障都会产生传染**
![](@attachment/Clipboard_2021-06-14-21-28-02.png)

## 测试
**测试理论的目标**
确定理想的测试——也就是说，确保软件在所有输入下都能工作所需的最小测试数据

### 几种测试
#### 单元测试(Unit Testing)
- 对软件的单个单元进行测试，以确保其正确工作。这可以是单个组件，也可以是复合组件
- 组件可以是方法、类或子系统。它可以是单个GUI组件(如按钮)或它们的集合(如窗口)
- 这利用了该单元的编程接口

#### 集成测试(Integration Testing)
- 测试两个或更多单元，以确保它们正确地互操作
- 这可以使用编程接口或系统接口
- 是自顶向下，自底向上，还是采用“端到端用户功能”的方法(这啥玩意

#### 系统测试(System Testing)
- 对整个软件系统进行测试，以确保它正确工作，满足/解决用户的需求/问题
- 本系统使用的系统界面可以是GUI、网络界面、web界面等...

#### 收敛测试(Acceptance Testing)
- 对整个软件系统进行测试，以确保其**满足用户需求**
- 同样，这使用了系统接口

##### 上述几种测试的直观联系
![](@attachment/Clipboard_2021-06-14-21-43-06.png)

#### 回归测试(Regression Testing)
- 在软件经历变更后确认或否认软件的功能
- 在发现并纠正bug时进行新的回归测试
- 确保您不会重新引入以前已修复的错误
>+ 保持严格的定期测试时间表
>+ 使用测试管理软件
>+ 对测试进行分类，以便理解
>+ 根据需要，例如客户的需求，确定测试的优先级

#### 穷举调试(Exhaustive Testing)
- 这通常是不可行的，因为这将花费太长时间或需要太多内存空间
- 一个好的测试应该有很高的发现错误的可能性，而不是重复另一个测试，在测量什么方面是独立的，这样错误就不会相互隐藏，并且尽可能多地测试代码

### 黑盒测试与白盒测试
#### 黑盒测试(功能测试)
生成执行规范的输入值，并将实际输出与预期输出进行比较。我们不知道测试过程中代码内部发生了什么，只关注输入与输出
> 完全基于程序规范，目的是**验证程序满足规定的要求**
黑盒测试**不会发现与额外功能相关的故障**。这些都是遗漏的错误
黑盒测试提供了规范的覆盖率，但**没有提供实现的全部覆盖率**。也就是说，实现中的代码可能产生规范中没有说明的结果

1. 根据规格进行测试。
2. 使用基于规格说明的测试覆盖率标准。
3. 开发来自规范的测试用例。
4. “锻炼”的规范。

##### 包括
- 等价类测试
将输入数据划分出几个等价区域，并在每个区域中测试一个值
- 边界值测试
测试边界值
- 组合测试
测试输入数值的组合
- 随机测试
选取随机数进行测试
![](@attachment/Clipboard_2021-06-14-21-59-29.png)

#### 白盒测试(结构测试)
生成执行实现的输入值，并将实际输出与预期输出进行比较。我们知道测试过程中每条代码上发生了什么，测试是根据代码的结构进行设计的
> 使用软件的实现来派生测试。这些测试的目的是**测试程序代码的某些方面**
白盒测试**不会发现与缺失功能相关的故障**。这些都是遗漏的错误
白盒测试**提供了实现的覆盖率**，而不是规范的覆盖率。也就是说，可能在规范中声明的行为在实现中没有代码

1. 对实现进行测试
2. 使用基于实现的测试覆盖标准
3. 开发来自实现的测试用例。
4. “锻炼”的实现
![](@attachment/Clipboard_2021-06-14-22-02-28.png)

#### 二者区别
![](@attachment/Clipboard_2021-06-14-21-56-03.png)

### 是不是应该结束测试了？
当满足以下三种情况的时候，我们可以考虑结束软件测试：
- 预算角度：分配的时间或预算已过期
- 活动角度：软件通过了所有计划的测试
- 风险管理角度：预测的故障率满足某些质量标准

### 静态验证与动态检验
言简意骇一句话：静态验证不需要执行软件代码，而动态验证需要执行
#### 静态检验(Static Verification)
- 静态验证(或静态分析)可以非常简单，就像让受过培训的人阅读代码并有经验来查找错误一样
- 它还可以采用一种数学方法，包括程序的符号执行
- 最后，它可以是一种正式的方法，包括规范和源代码之间转换的符号验证

#### 动态检验(Dynamic Verification)
- 动态验证(或软件测试)通过执行程序来确认程序的运行
- 创建的测试用例指导选择合适的测试数据(由输入值和期望输出值组成)
- 输入值在执行期间作为程序的输入提供
- 从程序中收集实际输出，然后将它们与预期输出进行比较
![](@attachment/Clipboard_2021-06-14-21-55-14.png)










