---
attachments: [Clipboard_2021-09-10-14-27-13.png, Clipboard_2021-09-10-14-35-23.png, Clipboard_2021-09-10-22-20-34.png, Clipboard_2021-09-10-22-26-52.png, Clipboard_2021-09-10-22-30-36.png, Clipboard_2021-09-10-22-54-05.png, Clipboard_2021-09-10-23-29-04.png, Clipboard_2021-09-10-23-32-02.png, Clipboard_2021-09-11-20-13-03.png, Clipboard_2021-09-11-23-09-55.png, Clipboard_2021-09-12-00-13-25.png]
tags: [Shader/Unity Shader]
title: §1-1.5：URP、HDRP与Unity Build-in 渲染管线
created: '2021-09-09T10:55:05.746Z'
modified: '2021-09-27T02:15:10.511Z'
---

# §1-1.5：URP、HDRP与Unity Build-in 渲染管线
## 内置渲染管线的渲染流水线
流程图如下。其中蓝色的部分为CPU流水线，绿色的部分为GPU流水线。
<center><img src="@attachment/Clipboard_2021-09-10-14-27-13.png" width=700></center>

看上去有点复杂，但简单来说就是：
CPU(应用阶段) --> GPU(几何阶段、光栅化阶段) --> 帧缓冲区(结果)
![](@attachment/Clipboard_2021-09-10-14-35-23.png)
当存在多个相机的时候，每个摄像机都会将各自的渲染管线完整的跑一遍。摄像机的优先级是depth参数(数值越小越先渲染，后渲染的会覆盖前渲染的)，由于摄像机的清屏属性(Clear Falg，在检查器中可以看到)，每次渲染的结果会覆盖其他相机的

### CPU阶段
**1. 剔除·Culling**
- 视锥体剔除
每个摄像机都有一个**视锥体**(下图中Gizmos标出来的几何体)，它的形状受视场(View of Field)、近裁面(Near Cliping Plans)、远裁面(Far Cliping Plans)和观察窗(Viewport Rect)的影响。
<img src="@attachment/Clipboard_2021-09-10-22-26-52.png" width=450 style="display: inline"><img src="@attachment/Clipboard_2021-09-10-22-30-36.png" width=400 style="display:inline">
在视锥体剔除阶段，系统会将物体与视锥体进行一个相交检测来判断我们应该绘制哪些物体
> 完全没有相交，表示这个物体处于视锥体之外，摄像机看不见这个物体，不需要绘制它
有部分相交，则表示这个物体一部分在视锥体内，一部分在视锥体外。摄像机只能看到该物体的一部分，我们只需要绘制这部分就好了
由于高面数模型进行视锥体相交检测时会消耗很多性能，所以我们会采取**包围盒**技术。常用的包围盒有包围球、AABB(轴对齐)包围盒和OBB包围盒来替代原物体的面碰撞器
<img src="@attachment/Clipboard_2021-09-10-22-54-05.png" width=400>

- 层级剔除
我们可以给所有物体设置它的层级：
![](@attachment/Clipboard_2021-09-10-23-29-04.png)
并且可以设定相机渲染的层：
![](@attachment/Clipboard_2021-09-10-23-32-02.png)
被排除在外的层不会被渲染，而会被剔除，这就是层级剔除。

- 遮挡剔除
顾名思义，它指的是两个物体相互遮挡时，剔除掉被遮挡部分的渲染。通过防止 Unity 为那些被其他游戏对象完全挡住（遮挡）的游戏对象执行渲染计算，我们可以提升游戏的性能。
其实没这么简单，挺复杂的...之后专门写个介绍的吧

**2. 排序·Sorting**
- 渲染队列
对于每个物体，它的材质的shader给它指定了一个渲染队列的值。当然，你也可以手动更改渲染队列的值。
默认情况下，渲染队列的值越小就越先被渲染。2500是一个分界点，当值小于2500我们认为这个物体是不透明的，而大于2500则是半透明的。
> **当渲染队列的值相同时**
这种情况下，我们使用物体与摄像机近裁面之间的距离作为渲染先后的指标。
当物体处于不透明渲染队列时，物体离摄像机近裁面越近就越先被渲染(不用重复渲染被遮挡的部分，节省性能开销)
当物体处于半透明渲染队列时，物体离摄像机近裁面越远就越先被渲染(远处的半透明物体需要先混合颜色)

**3. 调用SetPress Call**
设置各种渲染状态，告诉GPU使用哪个shader、哪种混合模式

**4. 调用Draw Call**
告诉GPU需要哪些模型数据
***
### GPU阶段
GPU阶段的渲染管线的内容我们在上一节里提到过了：
<center><img src="@attachment/Clipboard_2021-09-10-22-20-34.png" width=200></center>

用更为直观的方式来表示，就是(其中绿色的两个着色器是这个阶段中可编程的部分)：
![](@attachment/Clipboard_2021-09-11-20-13-03.png)
**1. 顶点着色器·Vertex Shader**
顶点着色器通常被称作vert，它最重要的任务是利用MVP变换矩阵将顶点坐标从模型空间转换到裁剪空间(利用了投影成像原理)。除了这个最基本的功能之外，也可以计算逐顶点光照、逐顶点漫反射等等。
MVP：模型空间(模型坐标系) -M-> 世界空间(世界坐标系) -V-> 视觉空间(相机坐标系) -P-> 裁剪空间
![](@attachment/Clipboard_2021-09-11-23-09-55.png)
> **什么是裁剪空间？**
裁剪空间指的是从位于相机坐标系(由相机近裁面和远裁面包裹起来的类金字塔形的部分)的视觉空间压缩成2：2：1的矩形状的坐标系之后的空间。这样做的目的是忽略相机本身的分辨率
<img src="@attachment/Clipboard_2021-09-12-00-13-25.png" width=400>

**2. 硬件操作阶段·图元装配及光栅化**
第一步：**视口变换**(公式可以参考http://eclipseflower.github.io/2017/01/13/viewport-matrix/)，可以得到顶点在屏幕空间的坐标
第二步：**图元装配**，将三个三个的顶点连成三角形形状的图元(还不是片元)，也就是三角形设置
第三步：**光栅化**，将片元内部进行插值，生成片元(片段)。片元可以理解成还没有显示到屏幕上的像素

**3. 片元着色器·Fragment Shader**
片元着色器通常被称作Frag，它对每个片元进行上色(逐片元)，比如逐片元光照计算、纹理映射等等
由于同个位置可能有多个片元在竞争，因此还需要**输出合并**的操作剔除掉不需要的片元。输出合并即对片元使用深度测试、模板测试或者深度混合


## URP与HDRP
接下来介绍两个对于内置管线的升级管线，即URP(通用渲染管线)和HDRP(高清渲染管线)，二者有所不同。都支持Post-Processing、Shader Graph和VFX(Visual Effect Graph)
### URP
URP的亮点是可以用于2D项目。2D光照能给2D游戏带来炫酷的效果
### HDRP
没有2D效果，相较于URP而言在光照上更为优秀
