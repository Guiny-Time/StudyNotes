---
attachments: [Clipboard_2021-04-27-21-32-06.png, Clipboard_2021-05-02-13-59-37.png, Clipboard_2021-05-02-14-00-07.png, Clipboard_2021-05-02-14-00-39.png, Clipboard_2021-05-06-10-54-43.png, Clipboard_2021-05-06-10-55-28.png, Clipboard_2021-05-06-11-00-28.png, Clipboard_2021-06-28-17-29-28.png, Clipboard_2021-06-28-17-32-45.png, Clipboard_2021-06-28-17-36-22.png, Clipboard_2021-06-28-17-39-08.png, Clipboard_2021-06-28-17-45-40.png, Clipboard_2021-06-28-18-02-06.png, Clipboard_2021-06-28-23-57-08.png]
tags: [大二/CS335软件工程与软件过程]
title: L7-系统分析与设计
created: '2021-04-27T13:30:48.454Z'
modified: '2021-09-27T06:14:02.637Z'
---

# L7-系统分析与设计
<markdwon>
  <details>
    <summary><center>目标1：context-DFD(上下文数据流图)</center></summary>

用于分析系统中数据的流向。在这个阶段我们只考虑整个程序和外部实体之间的联系

![](@attachment/Clipboard_2021-05-02-13-59-37.png)

### 图样分析
![](@attachment/Clipboard_2021-04-27-21-32-06.png)

#### 进程(Processing)
- **主要功能**：接收数据、处理数据(过程黑箱)、输出数据
- 可以有多个输入输出
- 规范命名(最好是名词收尾的形式)

#### 数据流(Data Flow)
- **主要功能**：显示数据流动的路径
- 可以表示一个或多个数据项
- 规范命名
- 路上至少经过一个进程

#### 数据存储(Data Storage)
- **主要功能**：表示存储的一个或多个将由进程处理的数据
- 不能与其他数据存储相连
- 规范命名

#### 外部实体(External Entity)
- 向系统提供数据
- 从系统获取数据
</details>
</markdown>
<markdown>
  <details>
    <summary><center>目标2：Level-0图</center></summary>

## Level-0图
在上下文数据流图的基础上进行扩展，将被隐藏的系统显示出来

![](@attachment/Clipboard_2021-05-02-14-00-07.png)

- level-0图提供了系统所有组件的概述
- 显示主要内部进程、数据流和数据存储
- 在level-0图的层次包括上下文图中已识别的外部实体
- 进程号并不表示进程执行的顺序
</details>
</markdown>

<markdown>
<details>
<summary><center>目标3：Level-1图(低级dfd图)</center></summary>

![](@attachment/Clipboard_2021-05-02-14-00-39.png)

•低级dfd的级别只能在所有功能原语被识别时才能确定(升级)
•所有低级dfd都基于上级确定的流程
•所有低级dfd的输入和输出数据流必须正确对齐(平衡)
</details>
</markdown>

### 目标图表总结
•数据流程图用于数据和流程建模。
•dfd显示系统中的数据移动和转换。
•dfd以层次结构组织细节层次。
•上下文图表示系统范围及其外部依赖关系。
•level-0图显示了系统的主要流程、数据存储、外部实体和数据流。
•低级图表(level-1图)显示了系统的附加细节。
•dfd应准确反映被建模的信息系统。
•dfd的完整集合应该扩展到原始层次，其中每个组件都反映了某些不可约的属性。这是一个迭代过程。

## 面向对象(OOP)
### 什么是面向对象编程(OOP)
面向对象编程是一种实现方法，在这种方法中，程序被组织为对象的协作集合，每个对象代表某个类的实例，其类都是通过继承关系统一的类层次结构的成员
> ”Object-oriented programming is a method of implementation in which programs are organized as cooperative collections of objects, each of which represents an instance of some class, and whose classes are all members of a hierarchy of classes united via inheritance relationships.” 

### 什么是面向对象设计(OOD)
面向对象设计是一种设计方法，包括面向对象的分解过程和描述被设计系统的逻辑和物理以及静态和动态模型的符号
> Object-oriented design is a method of design encompassing the process of object-oriented decomposition and a notation for depicting both logical and physical as well as static and dynamic models of the system under design


# 面向对象分析(OOA)
面向对象分析是一种分析方法，它从问题域词汇表中的类和对象的角度来检查需求
> Object-oriented analysis is a method of analysis that examines requirements from the perspective of the classes and objects found in the vocabulary of the problem domain

### 用例分析
实际上是从用户故事中分析需要写哪些类、类与类之间的关系
![](@attachment/Clipboard_2021-05-06-10-54-43.png)
![](@attachment/Clipboard_2021-05-06-10-55-28.png)

### 类间分析
- 主要从经典范畴原则派生类和对象
- 关注问题领域的有形事物

### 行为分析
- 关注动态行为作为类和对象的主要来源。
- 基于具有相似行为的对象组的窗体类。
- 将有共同责任的事情分组。
> 类的层次结构从一般的职责到专门的行为被创建

- 由系统函数导出
1. 将系统行为分配给系统的各个部分
2. 了解谁发起这些行为，谁参与这些行为
3. 起重要作用的发起者和参与者被视为对象。

### 类-职责-协作卡(CRC)
图样：
![](@attachment/Clipboard_2021-05-06-11-00-28.png)

包含了：
- 类的继承关系(父类、子类)
- 对该类的描述
- 变量(变量名和它的描述)
- 职责(不同于类的方法，但是方法履行职责)
执行对象的职责与了解对象的职责

其分析作用是
- 回顾用例图的描述
- 识别相关的参与者和对象
- 用例图场景的角色扮演
- 重复上面的步骤，直到所有的用例都被执行

## 结构分析
### 流程建模
详见DFD图

### 数据建模(Data Modelling)
#### 什么是数据建模
数据建模指的是一个详细的模型，它捕获组织数据的整体结构，独立于任何数据库管理系统或其他实现考虑
- 数据建模建立发展数据中的定义、结构和关系。
- 数据建模解释了需要组织做什么，以及管理在组织中执行的工作的规则。
- 数据模型不关心数据何时被处理或使用。
- 概念数据建模通常与其他需求分析和系统分析活动一起执行，如流程建模和逻辑建模。
- 工作和活动通常通过项目字典或由通用计算机辅助软件工程(CASE)软件工具维护的存储库进行协调和共享。
- 数据建模最常用的技术是实体关系(E-R)图

#### 数据建模的重要性
- 在数据库、程序、计算机屏幕和打印报告的设计中，数据的特性是很重要的。
- 数据是许多现代信息系统中最复杂的方面。
> 事务处理系统，如订单处理系统，在验证数据、协调错误和协调数据移动方面可能会有相当大的过程复杂性。

- 数据的特征，如格式和实体关系，相对稳定，并且在同一业务领域的组织之间基本相同。
> 基于面向数据而不是面向流程或逻辑的信息系统设计应该有更长的使用寿命。

#### 为数据建模收集信息！
概念数据模型可以从头开始开发、从现有数据模型中提炼或购买(特定业务领域的标准数据模型)。数据建模通常是从多种角度进行的：
- 自上而下的方法
从对业务性质的理解中获取数据模型的业务规则(面试，询问具体问题)

- 自下而上的方法
审阅特定的业务文件，如报告和收据等。

### 实体关系建模(E-R Modelling)
E-R图是实体关系模型的图形化展示，被用于数据建模。该建模方式是数据库设计中常用的方法，建模符号由三个主要的构造(数据实体、关系、相关属性)组成

#### 实体(Entities)
实体指的是存在于用户环境中的一个人、一个地方、一个事件、一个对象等等，拥有自己的身份，有别于其他实体。
实体类型(或实体类)是共享共同属性或特征(类似于OOD中的“类”)的实体的集合，比如各种品种的猫猫的实体组成猫的实体类型。
实体实例是实体类型的单一出现(类似于OOD中的“对象”)，比如从猫猫实体类中实例化出深红大猫猫，大猫猫是唯一的

对实体类型的定义应该包括：
- 实体类型的每个实例的唯一特征(属性)是什么。
- 在实体类型中包含和不包含什么实体实例。
当- 创建和删除实体类型的实例时。当一个实例可能变成另一个实体类型的实例时。
例如:对建筑公司的投标一旦被接受就成为合同。
- 什么历史是可以保存的。

#### ER模型变量
你就参考OOD里头类的变量来就完事了
比如员工类，变量有名字、年龄、技能、员工代码等等
每个实体类型都必须具有一个或一组属性，以区别同一个类型的其他实例。属性或属性的集合称为候选键(Candidate Key, 你是不是想到了数据库的键...差不多)
- 一个可以包含多个值的属性称为多值属性(Multivalued Attribute)
- 几个重复到一起的属性称为重复组(Repeating Group)
> 使用一对大括号括起重复组或多值属性

- 对于每个实体实例必须有一个值的属性称为必选属性(Required Attribute)
- 一个不能为每个实体实例都有值的属性称为可选属性(Optional Attribute)
- 一个有意义的组成部分被称为复合属性(Composite Attribute)
- 可以从数据库中其他数据计算出的属性值称为派生属性(Derived Attribute)
![](@attachment/Clipboard_2021-06-28-17-29-28.png)

#### ER模型关系
- 关系是**组织**感兴趣的**一个或多个实体类型的实例之间的关联**。
- 关系通常意味着**一个事件已经发生**，或者**实体实例之间存在一些自然的联系**。
- 关系用动词短语来标记。
- 参与关系的实体类型的数量被称为关系的程度。
>+ 一元关系(或递归关系)、二元关系和三元关系是常见的。
>+ 更高程度的关系是可能的，但在实践中很少遇到。
![](@attachment/Clipboard_2021-06-28-17-32-45.png)

##### 关系基数
![](@attachment/Clipboard_2021-06-28-17-36-22.png)
首先我们来看一堆魔法棒，他英文名字挺直白的，叫牛脚符号(Crow's Foot Symbols)。。
这堆奇奇怪怪的跟召唤恶魔的奇怪符号一样的符号指的是可以(或必须)与实体A的每个实例相关联的实体b的数量，自上而下分别是：
- 一个或者更多个
- 要么一个，要么没有(欢迎来到0与1的世界)
- 就一个
- 要么0，要么1，要么一堆

应用到实体实例中就是：
![](@attachment/Clipboard_2021-06-28-17-39-08.png)

#### 超类型(Supertypes)与子类型(Subtypes)
可以理解成OOD中的继承父类和子类
- 子类型
实体类型中的实体的一个子组，它对组织具有完全意义，并具有不同于其他子组的公共属性或关系
- 超类型
与一个或多个子类型有关系的泛型实体类型
![](@attachment/Clipboard_2021-06-28-17-45-40.png)

上图中，Employee是底下两个的父类

##### 关系规则
为了避免出现超级老虎吃屎的问题，我们需要制定规则
- 总专业化规则
•指定超类型的每个实体实例**必须是关系的某个子类型**的成员。例如，一个人必须是员工或学生或两者都是。
•从超类型到圆的双行

- 重叠规则:
•指定一个实体实例**可以同时是两个或多个子类型的成员**。一个人既可以是雇员也可以是学生
•在圈里写个“o”

- 局部特殊化规则
•指定父类型的实体实例**不必属于任何子类型**。例如，一个员工可以只是一个员工，一个员工不必是教员或员工。
•从超类型到圆的一行

- 不相交的规则:
•指定如果超类型的实体实例是一个子类型的成员，它**不能同时是任何其他子类型的成员**。例如，一个人必须是雇员或学生。
•在圈里写个“d”
![](@attachment/Clipboard_2021-06-28-18-02-06.png)

# GRASP(General Responsibility Assignment Software Pattern or Principles)原则
领域模型(Domain Model)是概念类或领域中实际情况对象的可视化表示
## GRASP-创造者(Creator)
创造者指：谁创造了谁？
如果A和B之间有以下关系中的一个，我们就可以认为B是A的创造者：
- B包含或复合聚合A
- B记录A
- B紧密使用A
- B拥有A的初始化数据。

举个例子，“项目”这个实体拥有“项目待办列表”这个实体的所有数据，所以我们认为项目是项目待办列表的创造者

## GRASP-信息专家(Information Expert)
给对象分配职责的基本原则是将一个职责分配给具有完成该职责所需信息的类
说人话就是：谁能(有信息)干给谁干
比如说产品待办列表有所有的用户需求信息，所以它负责用户故事

## GRASP-低耦合(Low Coupling)
当系统的耦合度低时，我们改动系统的一部分代码时不会对其他部分造成太大的影响
低耦合的方法：分配职责，使不必要的耦合保持在较低水平。使用这个原则来评估替代方案

## GRASP-控制者(Controller)
谁是控制者？
将责任分配给代表以下选择之一的对象:
- 表示整个系统，一个“根对象”，一个软件运行的设备，或一个主要子系统(façade控制器的变体)。
- 表示系统操作发生的用例场景(用例或会话控制器)。

## GRASP-高内聚(High Cohesion)
如何保持对象集中、可理解和可管理，以及作为一个副作用，支持低耦合?这就需要高内聚，分配责任，保持高度的凝聚力。用它来评估替代方案
高内聚是指类与类之间的关系而定.高，意思是他们之间的关系要简单明了，不要有很强的关系
内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系

## GRASP-多态(Polymorphism)
如何基于类型处理备选方案? 如何创建可插拔的软件组件?
解决方法：多态
> 当相关的替代方案或行为随类型而变化时，使用多态操作将行为的责任分配给行为所变化的类型
好处是新变体的扩展容易添加，并且可以在不影响客户机的情况下引入新的实现(热拔插)

## GRASP-纯制造，间接和保护变异(Pure Fabrication, Indirection and Protected Variations)
### 纯制造
当你不想违背高内聚低耦合的原则，但是解决方案又不完美的时候该怎么办？
将一组高内聚的职责分配给一个不代表问题域概念的人工或方便类，以支持高内聚、低耦合和重用。如类(class)是一种虚构的想象。

### 间接
在哪里分配责任，以避免两个或多个事物之间的直接耦合?如何对对象进行解耦合，以支持低耦合，并保持较高的重用潜力?
解决方法是将责任分配给中间对象，以便在其他组件或服务之间进行中介，这样您的组件或服务就不会直接耦合
常见的应用在于适配器模式、桥接模式、观察者模式、中继器模式、外观模式

### 突变保护
如何设计对象、子系统和系统，使这些元素的变化或不稳定性不会对其他元素产生不良影响?
解决方法是识别预测的变化或不稳定点;为它们分配创建稳定接口(广义的访问视图)的职责
常见的应用在于许多设计原则中，比如多态、接口、封装与绝大多数设计模式

# 面向对象五大原则(SOLID)
## SOLID
- SRP单一职责原则
- OCP开闭原则
- LSP里氏替换原则
- ISP接口隔离原则
- DIP依赖反转原则

### 单一职责原则
一个类干一件事并干好，每个模块或类都应该对软件提供的功能的单个部分负责(高内聚)

### 开闭原则
模块应该是开放的(为了扩展和适应)和封闭的(模块以影响客户端的方式关闭修改)
比如工厂模式，一个很好的符合开闭原则的设计模式
![](@attachment/Clipboard_2021-06-28-23-57-08.png)

### 里氏替换原则
如果对于每个类型为S的对象o1，都有一个类型为T的对象o2，使得所有以T定义的程序P，当o1取代o2时，P的行为保持不变，那么S就是类型为T的子类型

### 接口隔离原则
不应该强迫客户端依赖于它们不使用的接口，只继承该用的接口

### 依赖反转原则
> 对抽象接口的每一次更改都对应于对其具体实现的更改。相反，对具体实现的更改并不总是(甚至通常)需要对其实现的接口进行更改。

依赖反转原则是指一种特定的解耦（传统的依赖关系创建在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。

#### 该原则规定
- 高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。
- 抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。
- 该原则颠倒了一部分人对于面向对象设计的认识方式。如高层次和低层次对象都应该依赖于相同的抽象接口

## 总结
- GRASP原则可以作为一个工具，帮助掌握OOD的基础知识，理解对象设计中的责任分配。
- GRASP遵循责任驱动设计的理念，思考如何将责任分配给协作对象。
- GRASP和SOLID基本重叠。









