---
attachments: [Clipboard_2021-08-31-21-47-53.png, Clipboard_2021-08-31-21-48-56.png, Clipboard_2021-08-31-21-51-05.png, Clipboard_2021-08-31-21-54-39.png, Clipboard_2021-08-31-22-04-57.png, Clipboard_2021-08-31-22-11-57.png, Clipboard_2021-08-31-22-20-41.png, Clipboard_2021-09-02-21-05-58.png]
tags: [Unity Shader]
title: §4：基础纹理
created: '2021-08-31T12:06:47.428Z'
modified: '2021-09-02T13:31:35.186Z'
---

# §4：基础纹理
## 基础概念
- 纹理映射(Texture Mapping)
纹理映射指的是将一张贴图映射在模型表面，逐纹素(texel)的控制模型的颜色。
- 纹理映射坐标(Texture-mapping Coordinates)
通过模型的纹理展开(展uv)，我们可以获得一组纹理映射坐标，储存在每个顶点上。通常纹理映射坐标由(u, v)来表示，所以我们会简称纹理映射坐标为UV坐标。
不管贴图实际上有多大，UV坐标的范围通常被归于[0, 1]之间，并以纹理贴图的左下角为原点

### 纹理属性
在向Unity导入纹理之后，检查器中可以对纹理进行一系列设置：
![](@attachment/Clipboard_2021-08-31-21-47-53.png)
- 纹理类型(Texture Type)
我们可以选择设置成普通的纹理贴图、法线贴图、光照贴图等等。合适的类型能让Unity更好的针对贴图进行优化
![](@attachment/Clipboard_2021-08-31-21-48-56.png)

- 透明通道源(Alpha Source)
设置透明通道的值。默认透明来自于贴图本身，但是也可以通过灰阶来设置透明通道
![](@attachment/Clipboard_2021-08-31-21-51-05.png)
  
- 平铺模式(Wrap Mode)
决定了当纹理坐标超过[0, 1]之后的平铺方式。想要调用这个效果需对顶点纹理坐标进行相应变换(例如通过ST缩放偏移获取新的uv坐标等等)
![](@attachment/Clipboard_2021-08-31-21-54-39.png)
> Repeat：循环，贴图是重复的
Clamp：截取，超出部分会延续边界的值
Mirror：镜像，超出部分对称返回

- 滤波模式(Filter Mode)
相当于PS中改变图像大小时选择的模式。滤波模式决定了当纹理被放大或缩小时使用哪种滤波模式。按照滤波效果和性能排序，三种模式的顺序为：Point < Bilinear < Trilinear
![](@attachment/Clipboard_2021-08-31-22-04-57.png)
> Point：最近邻(Nearst Neighbor)，得到类似像素的风格，非常适合本身就是像素风格纹理的放大缩小
Bilinear：两次线性，对于每个像素与临近的四个像素进行线性插值，得到有些模糊的感觉
Trilinear：两次线性(立方)，在基于Bilinear的基础上对多级渐远纹理进行的混合

- 多级渐远纹理(Mipmapping)
通过勾选下列选项即可开启多级渐远纹理。这通常应用于将纹理缩小、或者纹理延伸到无穷远以至于远处的纹理是十分小的情况。多级渐远通过提前对纹理进行滤波得到纹理金字塔来减少渲染时间(牺牲空间换取时间)
![](@attachment/Clipboard_2021-08-31-22-11-57.png)

- 纹理大小(Texture Size)
我们可以设置纹理的最大大小作为纹理的最大分辨率。理想情况下，纹理应该是正方形的，并且长宽的大小是2的幂。NPOT(Non Pow Of Two)类型的纹理处理会占用更多的内存，读取速度也会有所下降甚至不被支持
*当对纹理没有特殊要求的时候，请压缩纹理来节约空间
![](@attachment/Clipboard_2021-08-31-22-20-41.png)

## 凹凸映射
凹凸映射主要有两种方式，即高度映射(Height Mapping)和法线映射(Normal Mapping)。凹凸映射通过修改物体表面的法线来为物体提供更多细节，使模型看起来更逼真(但不会真的改变模型顶点的位置)
### 高度映射
- 使用储存了强度值(Intensity)的高度图/高度纹理(Height Map)来模拟表面位移，即表面局部的海拔高度。
- 高度纹理通过颜色非常直观的表示了高度，颜色越浅表示表面越向外凸起、颜色越深表示表面越向内凹。
- 高度纹理通过灰度计算得出法线，不能直接得到法线值，需要消耗更多性能

### 法线映射
- 法线纹理通过颜色来表示法线。但由于像素RGB的分量在[0, 1]范围，而法线的分量在[-1, 1]范围，因此需要使用以下公式进行映射：
$$pixel = \frac{normal + 1}{2}$$
- 法线纹理储存在模型空间或模型切线空间中
- 法线纹理(Normal Map)储存的是法线本身，因此使用法线纹理的处理速度比高度纹理更快
#### 模型空间的法线纹理(Object-space Normal Map)
记录**模型空间内各点的法线方向**，通过映射公式后得到的法线纹理。模型空间的法线纹理较为直观，可以看出凹凸情况、五颜六色
模型空间的法线纹理有以下几个优缺点：
- 实现简单、表现直观
不需要原始模型的法线/切线信息，只需要记录各个顶点的法线方向
- 缝隙较少、平滑边界
模型空间的法线纹理能够对边界处进行线性插值以获得更平滑的效果
- 低自由度
模型空间的法线纹理是固定的(绝对法线信息)，当模型产生改变便不再合适，也无法应用于UV动画

#### 切线空间的法线纹理(Tangent-space Normal Map)
与模型空间的法线纹理不同的是，切线空间的法线纹理记录的是法线的扰动值，或者说偏移量，是一个相对的法线信息。
对于模型的任意一个顶点，我们可以找到一个切平面，其中上面的任意一条直线都是该顶点的切线。对于切平面垂直的直线即该顶点的法线。我们记录的是新的法线较原本法线的偏移量，如下图所示：
![](@attachment/Clipboard_2021-09-01-11-16-28.png)
由于映射公式的特性，切线空间的法线纹理基本是蓝色色调的(当法线并没有任何偏移时也是蓝色)
切线空间的法线纹理有以下几个优缺点：
- 高自由度、可用于UV动画
因为是相对的法线纹理，所以当模型发生变化的时候，也能得到一个合理的效果。并且可以用在水、熔岩这样流动的物体效果上
- 可重用
一张切线空间的法线贴图可用在多个物体上，比如一块砖的六面
- 可压缩
我们可以只储存切线空间的XY分量来推导法线的Z分量。而对于模型空间的法线纹理则必须记录三个分量

#### 法线映射的光照计算
##### 切线空间下计算光照
- 效率更高
- 通用性更差
在切线空间下计算光照，需要将光照和视角方向转换到切线空间再进行计算。这些操作可以在顶点着色器中完成。
但由于一些时候我们需要在世界空间才能完成一些计算，所以不通用。

##### 世界空间下计算光照
- 效率更低
- 通用性更高
在世界空间下计算光照，需要对纹理进行采样，将法线转换到世界空间再计算。这些操作需要在片元着色器中完成。
因为是在世界空间完成的计算，所以通用性更高。

## 渐变纹理
这种纹理能够更加灵活的控制光线和阴影以达到更为微妙的效果，比如下图中类卡渲风格和阴影异色模糊渐变的效果：
![](@attachment/Clipboard_2021-09-02-21-05-58.png)
真正意义上的卡渲的高光不是这样的，在之后的章节会提及





***
## Shader函数学习：tex2D
- tex2D(sampler2D tex, fixed2 s)
```ShaderLab
tex2D(_MainTex, i.uv);
```
这个方法其实就是对一张纹理_MainTex中的一个点进行采样。我们要得到整个纹理的颜色，就需要所有像素对应的uv点(并储存到一组纹理uv中)

