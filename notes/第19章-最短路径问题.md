---
tags: [大二/CS211算法与数据结构II]
title: 第19章-最短路径问题
created: '2021-07-06T07:52:26.215Z'
modified: '2021-09-27T02:19:38.495Z'
---

# 第19章-最短路径问题

## 定义
最短路问题解决的是图中最短距离(路径的权重和最小)
- 单对单最短路径问题(1-1)
求两个点之间的最短路径，最有名的算法是A*寻路算法
- 单对多最短路径问题(1-n)
求一个点到其余点的最短路径，有名的算法有Dijkstra和Bellman Ford算法
- 多对单最短路径问题(n-1)
求从所有的顶点到一个目标顶点的最短路径，有名的算法是Dijkstra算法(迪杰斯特拉，yyds)
- 多对多最短路径问题(n-n)
求每对顶点之间的最短路径，有名的算法是Floyed-Warshall和Johnson算法
<br>

## Relaxation
### 最优子结构性质
如果在一个图G上，两个节点u和v之间的最短路径为P，z在P点上
那么，P上u到z的路径是uz之间的最短路；P上z到v的路径是zv之间的最短路

### 防止转圈的原则
- 所有边的权重都是正数
最短路不能包含圈圈
- 所有边的权重都是非负数
0循环可以出现在最短路径中，但是可以在不改变长度的情况下被删除
- 一些边有负数权重
如果图中有负权环，那么最短路径问题就没有明确定义。
否则，我们将回到上述两种情况中的一种
- **最短路中，n个节点的图中最多有n-1条边**

### 三角形不等式
对任意(u,v) ∈ E，有δ(s,v) ≤ δ(s,u) + w(u,v)
δ(s,v)指的是s和v之间**最短路径**的总权值
w(u,v)指的是u和v之间**任意路径(可能是最短路)**的总权值
> 从s到u的最短路径加上从u到v的单边路径就是从s到v的路径。这个路径的长度必须至少等于从s到v的最短路径的长度

### 上界性质
对于s到v的路径，有：
- d[v] = s到v的路径的权重值
- p[v] = s到v的路径上v的前身
d[v] = d[u] + w(u, v) ≥ δ(s,v) + w(u, v) ≥ δ(s,v)
所以d[v] ≥ δ(s,v)，一旦二者相等，那么d[v]不再改变
<br>

## Bellman-Ford算法
1-n类型最短路径算法
### 实现步骤

### 时间复杂度
O(|V| |E|) = O(|V|^3^)




## <font color="red">Dijkstra算法</font>
1-1类型最短路径算法
### 实现步骤
1. 首先，创造一个未访问节点的列表，把所有节点装进去。初始化源节点到其他节点的代价为无穷
2. 选取要查找的源节点，将所有与其相连的边进行relax(就是加起来)，源节点加入已访问列表
3. 选取获得值的节点中权重最小的那个，继续relax，并加入已访问列表
4. 重复以上操作直至所有节点都已经访问

### 时间复杂度
#### 使用矩阵结构
O(|E| + |V|^2^) = O(|V|^2^) 
> |E| = |V|^2^
其中，relax操作的时间复杂度为O(1)，但是一共有E条边，所以需要进行E次
选取节点的时间复杂度为O(V),v为节点个数

#### 使用堆的结构
O((|E| + |V|)log|V|) = O(|E| log|V|) 

### 小心负数权重
像Dijkstra算法这样的最短路径算法无法检测到这样的循环，会给出错误的结果，因为它们可以通过一个负权循环并减少路径长度


## Floyed-Washfell算法
### 实现步骤
- 建立一个矩阵，存放节点之间的最小路径
- (1,1)这样的节点的值为0

### 时间复杂度
O(V^3^)


