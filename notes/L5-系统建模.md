---
attachments: [Clipboard_2021-05-02-10-58-18.png, Clipboard_2021-05-02-11-09-17.png, Clipboard_2021-05-02-11-11-05.png, Clipboard_2021-05-02-13-20-14.png, Clipboard_2021-05-02-13-21-49.png, Clipboard_2021-05-02-13-24-39.png, Clipboard_2021-05-06-22-46-38.png]
tags: [大二/CS335软件工程与软件过程]
title: L5-系统建模
created: '2021-04-13T07:51:15.709Z'
modified: '2021-09-27T06:14:08.035Z'
---

# L5-系统建模

<markdown>
<details>
<summary><center>目标1: 上下文图(Context Diagram)编写</center></summary>

结构如下：

![](@attachment/Clipboard_2021-05-02-10-58-18.png)

主要由两个结构组成
- 系统或外部系统
由方框表示，上部分用<<>>括起来的是类型，用来描述模型元素
类型有use、include、import和system等等，一般用到的是system

- 联系
表示了系统与外部系统之间的联系，用实线表示
</markdown>
</details>

<markdown>
<details>
 <summary><center>目标2: 活动图(Activity Diagram)编写</center></summary>

结构如下：

![](@attachment/Clipboard_2021-05-02-11-09-17.png)

好吧结构有点多，看一下图例吧：

![](@attachment/Clipboard_2021-05-02-11-11-05.png)

### 流程
- 初始节点(Initial Node)
实心黑点，表示执行活动的起点
- 分支节点(Decision Node)**异步**
菱形，一进二出。会因为真或假(比如接受或拒绝)产生两个分支，两个分支流向不同的结果
- 合并节点(Merge Node)**异步**
菱形，多进一出。可以在不同步的情况下将多个流聚集在一起
- 分叉节点(Fork Node)**同步**
长条，一进多出。并行操作的分支起始，从分叉节点可以开启多个并行操作
- 汇合节点(Join Node)**同步**
长条，多进一出。可以在同步的情况下将多个流聚集在一起
- 对象节点(Object Node)
矩形框，上面有<<>>表示的对象类型，比如数据存储(datastore)、系统(system)等等
- 终止节点(Final Node)
实心黑点外面还有一个圆圈，表示活动的终点

### 关于分支合并（Decision and Merge Nodes）与分叉汇合（Fork and Join Nodes）
这两个东西有点像，在上面的描述大概是同步和异步之间的区别
- 分支同步：处理决策，决策的的结束不一定(或者说极小概率也行)是同步结束的，所以说它的异步的
- 分叉汇合：对象在运行时可能会存在两个或多个**并发运行的控制流**，为了对并发的控制流建模，UML中引入了分叉与汇合的概念。分叉用于将动作流分为两个或多个并发运行的分支，而汇合则用于**同步**这些并发分支，以达到共同完成一项事务的目的
</markdown>
</details>

<details>
  <summary><center>目标3: 包图(Package Diagram)编写</center></summary>
  <markdown>

结构如下：

![](@attachment/Clipboard_2021-05-02-13-21-49.png)

### 什么是包(Package)
包被认为是其成员的名称空间，在java中是package，在C#中相对于namespace
### 包图的作用
- 当执行分析时，包图被用来组织开发的工件
- 提供封装和包容，并支持模块化
- 在复杂的系统开发中提供清晰和整洁的组织
- 支持版本控制
### 图样

![](@attachment/Clipboard_2021-05-02-13-20-14.png)

上面有两种关系，从属(Dependency)与控制(Containment)。从属表示一个包在没有另一个包的情况下无法正常运行；控制表示一个包需要另一个包才能工作
</markdown>
</details>

<details>
 <summary><center>目标4: 部署图(Deployment Diagram)编写</center></summary>
  <markdown>

结构如下：

![](@attachment/Clipboard_2021-05-02-13-24-39.png)

由六部分组成
- 节点
表示硬件或者软件运行环境的元素
- 工件
上面有<\<artifact\>>标记，代表了物理世界中由软件开发过程或系统操作所使用或产生的一些具体元素。如可执行文件、源文件、数据库表、文档或消息等
- 设备
节点的子类型，上面有<\<device\>>标记。它被用来表示具有处理能力的物理计算资源，工件可以在其上部署以供执行。
- 通讯路径
用实线表示，是两个部署目标之间的一种关联类型，它们可以通过它交换信息
- 运行环境
节点的子类型，上面有<\<excutionEnvironment\>>标记，被用来表示一些支持工件执行的环境(主要是软件)。运行环境通常分配给设备或节点。例如，应用服务器、操作系统或数据库等
- 部署规范
上面有<\<deployment spec\>>标记部署规范指定了部署在节点上的工件的一组属性
</markdown>
</details>

## 目的
- 对一个已经存在的系统
帮助阐明现有系统做什么，以明确系统的优缺点。
- 对于一个新系统（还不存在的，准备开发的系统）
有助于解释需求，让需求更明确、有助于写出系统文档

## 系统建模四要素
- 外部External:系统所处的外部环境和“上下文”（意思是系统的工作，比如说用了第三方接口，或者第三方服务，比如说用了百度地图服务，天气预报接口。运行的环境不只有自己，还有别的外部（external）工具，这就叫外部环境）
> 使用Context Model与Business Model(就是活动图)来实现（见本节课目标）

- 交互Interaction:系统与环境/与用户之间的交互，或是系统内部部件与部件之间的交互（比如说这个方法，调用了那个方法，方法就是内部的“部件”）
> ![](@attachment/Clipboard_2021-05-06-22-46-38.png)

- 结构Structural:系统的结构，或者系统要处理的数据的结构
> 根据组件的功能，和他们的关系来建模；用于设计系统的整体架构；它使用Class Diagram来建模

- 行为Behavioral: runtime  behavior就是系统运行过程中，如何对外界作出响应

## 总结
- 模型(model)是系统的抽象视图，它故意忽略了一些系统细节
- **上下文图** 上下文模型(context model)显示了系统在操作环境中的位置。它有助于定义系统的边界
**UML没有专门为上下文模型提供的图表！！！**
> •在需求工程的早期阶段创建
•了解并确定正在开发的系统的边界
•在没有细节的情况下，建立系统和运行环境之间交互的高层视图。
•使用简单的块图或空的类图

- **活动图** 商业处理模型
与商业业务有关的建模
> •建模业务流程
•描述系统在特定的业务流程中是如何被涉及的
•使用活动图或专用的业务流程模型和符号(BPMN)

- **用例图** 描述外部参与者和要开发的系统之间的交互序列图用于显示系统对象之间的交互
- **类图** 定义系统的类及其关系的静态结构
- **包图** 用于组织开发过程的工件
- **部署图** 用于显示组件对物理节点的分配

