---
attachments: [Clipboard_2021-07-07-09-42-03.png, Clipboard_2021-07-07-09-42-40.png, Clipboard_2021-07-07-09-43-01.png, Clipboard_2021-07-07-09-43-14.png, Clipboard_2021-07-07-09-43-31.png, Clipboard_2021-07-07-09-44-01.png]
tags: [CS211]
title: 第18章-最小生成树
created: '2021-07-06T07:52:13.275Z'
modified: '2021-07-07T03:34:39.182Z'
---

# 第18章-最小生成树

## 定义
给定一个无向图，可以从图中生成一颗二叉树，将所有节点相连。一张图可以有多个生成的二叉树。
对于一个有权的连通无向图，最小生成树(minimum spanning tree, MST)或最小权值生成树是指一棵生成树的权值小于或等于每棵生成树的权值。
> 生成树的权值是生成树中每条边的权值之和
**最小生成树有(V - 1)条边，其中V是给定图中的顶点数**

## 并查集
- 查(Find)：确定特定元素所在的子集。可用于确定两个元素是否在同一个子集中
- 并(Union)：将两个子集合并到一起
> 快速学习视频：https://www.youtube.com/watch?v=0jNmHPfA_yE
列出节点与其父节点。在算法一开始的时候，所有节点的父节点都是其本身
在最小生成树生成的同时改变节点的父节点，使你要合并的边成为一个集
当你要合并已经是一个集中的两条边的时候，这样会形成一个环，我们不能这样合并，需要跳过

## Kruskal算法
### 实现步骤
1. 对**所有边**按其权值的非递减顺序排序
![](@attachment/Clipboard_2021-07-07-09-42-03.png)
2. 选择最小的边，判断是否成环(使用并查集来探测)。如果不成环，将这条边算进MST，否则忽略它
3. 重复操作直到所有点都包括进树

这个算法的**核心是贪心思想**，体现在每次选择权重最小的边(要检查是否成环)

### 时间复杂度
O(|E|log |E|) 或者 O(|E| log|V|)。其中E为边数，V为总点数
- 对边进行排序的时间复杂度为O(|E|log |E|)
- 并查集操作的时间复杂度为O(|E|log |V|)
- 总时间复杂度为上面两项相加，由于E = V^2^,所以O(log |E|)与O(log |V|)是一样的(时间复杂度忽略系数)
- 最终得到时间复杂度为O(|E|log |E|)或O(|E|log |V|)

## Prim算法
快速学习视频：https://www.youtube.com/watch?v=cplfcGZmX7I
1. 随便选择一个节点, 把它加进已访问的列表中
2. 列出该节点可通往的边，选取权重最小的边连线，将连接到的点加进已访问的列表中
3. 选择已访问节点的边，选取最小(注意不要形成环)的边继续操作
4. 最终得到MST

### 相邻矩阵表示法
- 创建一个集合mstSet，跟踪已经包含在MST中的顶点
- 为输入图中的所有顶点分配一个键值。初始化所有键值为INFINITE。为第一个顶点指定键值为0，以便第一个被选中
- 当mstSet不包含所有节点时：
1. 选择mstSet中不存在且键值最小的顶点u
2. 把u添加进mstSet
3. 更新u所有相邻顶点的键值。要更新键值，需要遍历所有相邻顶点。对于每一个相邻的顶点v，如果边u-v的权值小于v之前的键值，则将键值更新为u-v的权值

#### 时间复杂度
O(|V|^2^)

### 相邻链表表示法
- 创建一个大小为V的最小堆，其中V是给定图中的顶点数。最小堆的每个节点都包含顶点数和顶点的键值
- 初始化最小堆，第一个顶点为根(分配给第一个顶点的键值是0)。分配给所有其他顶点的键值是INF(无限)。
- 当最小堆非空时：
1. 从最小堆中提取最小值节点。取提取的顶点为u
2. 对于u的每个相邻顶点v，检查v是否在Min Heap中(尚未包含在MST中)。如果v在Min Heap中，其键值大于u-v的weight，则将v的键值更新为u-v的weight

#### 时间复杂度
二叉堆：O(|E| log |V|) 
斐波那契堆：O(|E| + |V| log |V|) 





