---
attachments: [Clipboard_2021-05-25-16-27-29.png, Clipboard_2021-05-25-21-26-18.png, Clipboard_2021-05-25-22-03-27.png, Clipboard_2021-05-25-22-03-46.png, Clipboard_2021-05-25-22-10-33.png, Clipboard_2021-05-25-22-27-13.png, Clipboard_2021-05-25-22-27-49.png, Clipboard_2021-05-26-14-26-04.png, Clipboard_2021-05-26-14-26-33.png]
tags: [CS335]
title: L8-设计模式
created: '2021-05-25T07:49:47.217Z'
modified: '2021-05-26T06:39:05.670Z'
---

# L8-设计模式
## 设计模式
### 概念
设计模式描述了一个在我们的环境中反复出现的问题，然后描述了该问题的核心解决方案，以这种方式，您可以使用该解决方案一百万次，而不必以同样的方式进行两次
> Design pattern describes a problem which occurs over and over again in our environment, and then describes the core of the solution to that problem, in such a way that you can use this solution a million times over, without ever doing it the same way twice

设计模式使得优秀的设计与架构被反复使用

### 动机
- 寻找合适的对象
> •在设计中需要考虑的因素太多，例如，继承、封装、多态、单一责任、接口编程等
•确定设计方法
- 确定对象的粒度
> •系统中对象的大小和数量
•类设计中的层次结构
•组合vs.继承
- 提升重用性
- 为变革而设计

### 分类
四人组对设计模式的划分有经典的23种，按照目的和范围可以划分为
#### 目的
- 创造性
处理对象的创建
- 结构性
处理类与对象的构成关系
- 行为性
处理类或对象的交互与分配职责
#### 作用范围
- 类
类与子类之间的关系，编译时的静态关系
- 对象
对象之间的关系，运行时的动态关系

### 模式元素
- 模式名
一个有意义的名字
- 问题领域
在上下文中反复遇到的问题，或者说此设计模式适用的问题发生的情况
- 解决方案
构成设计的元素、关系、责任和协作
- 反馈
使用该种设计模式的利弊
> 
**上下文情形**
描述了解决方案适用的问题类型
**问题**
问题指的是重复出现在上下文情景中
**解决方案**
构成设计的元素、关系、责任和协作

### 如何选择设计模式
- 考虑设计模式如何解决设计问题。
> •如何识别合适的对象，
•如何确定对象的粒度，
•如何指定对象接口，
•如何指定对象实现，
•如何平衡类继承和接口继承，
•考虑接口编程，而不是实现编程。

- 查找设计模式的意图以找到匹配。
- 了解设计模式之间的相互关系。
- 考虑一下如何使您的设计可重用。

### 设计模式总结
#### 创造型设计模式
- 抽象工厂模式
可以改变产品对象的种类
- 建造者模式
可以改变符合对象的创建方式
- 工厂模式
可以改变被实例化对象的子类
- 原型模式
可以改变被实例化的对象的一个类
- 单例模式
可以改变一个类的唯一实例

#### 结构型设计模式总结
- 适配器模式
可以改变对象的接口
- 桥接模式
可以改变对象的实现。
- 组合器模式
可以改变对象的结构和组合。
- 探测者模式
可以改变对象的职责而不需要子类化。
- 外观模式
可以改变子系统的接口。
- 享元模式
可以改变物品的存储成本。
- 代理模式
可以改变对象访问方式(它的位置)的代理


#### 行为型设计模式总结
- 责任链模式
可以改变一个对象来满足一个请求。
- 命令模式
在何时以及如何满足一个请求时可能会有所不同。
- 解释器模式
能改变一种语言的语法和解释的人。
- 迭代器模式
可以改变访问和/或遍历聚合元素的方式的迭代器。
- 中继者模式
对象可以改变对象之间的交互方式和交互方式。
- Memento模式
这可以改变存储在对象外部的私有信息以及存储时间。
- 观察者模式
可以改变依赖于另一个对象的对象的数量;如何将相关对象保持最新。
- 状态模式
可以改变一个对象的状态。
- 策略模式
可以改变算法使用的策略。
- 模板方法模式(?
可以改变算法的步骤。
- 访问者模式
可以改变应用于对象的操作而不改变它们的类

### 请注意
- 设计模式使代码难以阅读/理解/调试。
- 设计模式使软件结构变得复杂。
- 不恰当地使用设计模式会让事情变得更糟。
- 不要用设计模式来解决简单的问题。

## 单例模式
在整个程序生命周期中只实例化一个对象，防止多个对象存在造成冲突等问题，并且提供一个全局方法可供访问(GetInstance()之类的)
### 应用
- 操作系统使用文件系统来管理文件
- 访问硬件的接口
- 静态配置数据(配置文件)
- 日志记录对象(Logger)
- 访问缓存存储
- 线程池
> **同步锁 synchronized**
Synchronized关键字确保每次只有一个线程可以访问被该关键字修饰的方法。
Synchronized public static void 方法名(para ){}

### 代码实现
public class PrinterDriver {
private volatile static PrinterDriver printerDriver;
private PrinterDriver( ) {
}
public static PrinterDriver getPrinterDriver( ) {
  //如果不存在则实例化
if (printerDriver == null) {
  synchronized (PrinterDriver.class) {
    if (printerDriver == null) {
      printerDriver = new PrinterDriver();
    }
  }
}
return printerDriver;
}
…

### 单例模式与静态类的区别
#### 可访问性
- 静态方法: 每个类都可以自由访问静态变量。
- 单例方法:易于控制谁获得实例
#### 灵活性
- 静态方法方法:只复制一份
- 单例方法:如果需要，它可以配置一个指定数量的实例
#### 清晰程度
- 静态方法方法:可能污染命名空间
- 单例方法:不需要创建全局可见变量

### 优缺点
#### 优点
- 对客户端访问实例化的类能够直接控制
- 可以取代全局变量
- 创建的实例化数目是可控的
#### 缺点
- 在多线程模式中需小心使用
### 类图结构
![](@attachment/Clipboard_2021-05-25-16-27-29.png)

## 工厂模式
https://www.runoob.com/design-pattern/factory-pattern.html
### 扩展与应用
工厂方法模式将特定于应用程序的类从具体类型的实例化**解耦**
**使用接口创建对象，但让子类决定实例化哪个类**
在以下情况下考虑使用工厂模式:
- 一个类不能预测它必须创建的对象的类。
- 一个类希望它的子类指定它创建的对象。
- 类将责任委托给几个helper子类中的一个，你想本地化哪个helper子类是委托的知识。

### 代码结构
- 功能抽象类(或者接口)
包含了一些需要被实现的方法，比如Shape
- 具体的小东西
实现了接口方法，比如Circle、Rectangle等等
- 工厂(提货)
含有工厂方法(比如display、print之类的)，一般是用string进行匹配实例化？

### 类图结构
![](@attachment/Clipboard_2021-05-25-21-26-18.png)

## 外观模式
https://www.runoob.com/design-pattern/facade-pattern.html
### 扩展与应用
外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性，使子系统更易于使用
- 为复杂的子系统提供一个简单的接口。
- 由于客户端和抽象的实现类之间存在许多依赖关系，所以将子系统从客户端解耦。
- 使用façade为分层设计的每个子系统定义一个入口点

### 使用场景
- 操作系统使用façade将多个框架组合成一个。
- 程序编译器使用façade，让程序员的生活更轻松。
- Web服务使用façade作为入口点。
- 数据库连接器，例如Java数据库连接(JDBC)使用façade来隐藏连接建立的复杂性。
或者说：
1、为复杂的模块或子系统提供外界访问的模块
2、子系统相对独立
3、预防低水平人员带来的风险

### 代码结构
- 各种子类(或者说子系统们)
之间的关系挺独立的，各自有各自的功能
- 外观类
内部实例化了这几个类的对象，实现了对应方法并对外提供可调用的接口

### 类图结构
![](@attachment/Clipboard_2021-05-25-22-03-46.png)
![](@attachment/Clipboard_2021-05-25-22-03-27.png)
![](@attachment/Clipboard_2021-05-25-22-10-33.png)

## 适配器模式
https://www.runoob.com/design-pattern/adapter-pattern.html
### 扩展与应用
将类的接口转换为客户期望的另一个接口。适配器可以让类一起工作，否则由于不兼容的接口而无法工作
- 使用一个现有的类，但它的接口与你需要的不匹配。
- 创建一个可重用的类，与不相关的或不可预见的类协作，也就是那些不一定有兼容接口的类。
- 使用几个现有的子类，但通过子类化每个人来调整它们的接口是不切实际的。对象适配器可以适应其父类的接口。

### 继承vs对象组合
#### 类适配器
- 当我们想要适应一个类及其所有子类时，类适配器将无法工作。
- 适配器覆盖被适配的类的一些行为。
#### 对象适配器
- 一个适配器可以与许多适配器一起工作
- 适配器还可以一次为所有适配器添加功能。
- 很难覆盖被覆盖对象的行为

### 使用场景
- 多个数据库访问器
- 使用具有不兼容接口的工具包类
- 其他与桥接不兼容接口相关的通用问题
> 例如，手机充电器和适配器，存储卡适配器，电子插头和适配器等

### 代码结构
- 基础类
包含了一些有点过时的无法涵盖所有潜在问题的方法
- 进阶类
包含了新的解决潜在问题的方法
- 适配器
连接基础类和进阶类的桥梁，总之是要把两个合一块(我们三个就要在一起.jpg)

之后，客户端通过基础类就可以通过适配器调用进阶类的方法以实现对应功能

### 类图结构
![](@attachment/Clipboard_2021-05-25-22-27-13.png)
![](@attachment/Clipboard_2021-05-25-22-27-49.png)

## 观察者模式
https://www.runoob.com/design-pattern/observer-pattern.html
### 扩展与应用
在对象之间定义一对多的依赖关系，这样当一个对象改变状态时，它的所有依赖关系都会被通知并自动更新(一个分发布者与多个订阅者)
- 当改变一个对象需要改变未知数量的其他对象。
- 当一个对象应该能够通知其他对象，而不假设这些对象是谁。
- 当一个抽象有两个方面，其中一个依赖于另一个

### 代码结构
- 发布者类
当发布者的状态改变的时候，发布这一消息
- 订阅者类
当发布者发布消息的时候，接收该消息并作出对应的反馈(也可以不反馈)
**观察者模式可以只存在发布者而不存在订阅者**

### 类图结构
![](@attachment/Clipboard_2021-05-26-14-26-04.png)
![](@attachment/Clipboard_2021-05-26-14-26-33.png)





