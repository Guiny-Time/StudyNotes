---
attachments: [Clipboard_2021-03-18-19-44-52.png, Clipboard_2021-03-18-19-45-17.png, Clipboard_2021-03-18-19-53-23.png, Clipboard_2021-03-28-16-45-48.png, Clipboard_2021-03-28-16-53-42.png, Clipboard_2021-03-28-17-00-41.png]
tags: [CS211]
title: 第12章-二叉搜索树
created: '2021-03-17T13:35:36.552Z'
modified: '2021-04-01T08:13:08.641Z'
---

# 第12章-二叉搜索树
## 定义
BST在二叉树的基础上引入了左小右大的规则
一个父节点，它左边的元素必然小于其本身，而右边的元素则大于其本身
### 推理
- BST中**最小**的元素是叶子节点中最左边的那个
- BST中**最大**的元素是叶子节点最右边的那个
- 搜索元素的平均时间复杂度为O(log<sub>2</sub>n)，这同时也是BST的平均高度
- 退化的BST的高度可以达到n，这也是最坏的情况，O(n)
- 最好的情况是要找的元素是根节点，O(1)

## 实现
### 数据结构
BST中的每个元素有一个特殊的键值，其中根节点的key为1，**注意不是0**
<p align="center">
<img src="@attachment/CS211-5.png" width="600">
</p>

#### 代码实现
> class Node{
  &nbsp;&nbsp;&nbsp;&nbsp;int value;
  &nbsp;&nbsp;&nbsp;&nbsp;Node left;
  &nbsp;&nbsp;&nbsp;&nbsp;Node right;
  &nbsp;&nbsp;&nbsp;&nbsp;Node(int value){
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.value = value;
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right = null; left = null;
&nbsp;&nbsp;&nbsp;&nbsp;}
}

这个显然是一个用于定义Node属性的类，构造函数为Node赋值，Node类里定义了两种类型的Node（左节点或右节点）
***
### 数据插入
- 从根节点开始尝试插入。如果新node的值小于当前节点,插入到左子节点
- 如果新节点的值大于当前节点,插入到右子节点
- 当前节点为空时,我们已经达到了一个叶子节点,可以把新node插入在这个位置
#### 代码实现
> private Node add(Node current, int value){
  &nbsp;&nbsp;&nbsp;&nbsp;if(current == null){
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Node(value);
  &nbsp;&nbsp;&nbsp;&nbsp;}if(value > current.value){
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current.right = add(current.right,value);
  &nbsp;&nbsp;&nbsp;&nbsp;}else if(value < current.value){
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current.left = add(current.left,value)
  &nbsp;&nbsp;&nbsp;&nbsp;}else{
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return current;
}

#### 代码逻辑
- 如果新node小于当前node，往左边走
- 如果新node大于当前node，往右边走
- 如果当前node为空，则插入当前位置，返回一个新的Node对象，构造函数内输入value值
- 空的else的意思是相等，代表这个数已经存在，所以直接return
- 本质是**递归思想**
#### 封装
嗯，最好封装一下，新的方法里面只有一句
root = add(root,value);，因为是从根节点开始插入的

于是，我们创建一个BST，可以这么写：
<p align="center">
<img src="@attachment/CS211-6.png" width="600">
</p>

***
### 数据搜索
#### 代码实现
<p align="center">
<img src="@attachment/CS211-7.png" width="600">
</p>

#### 代码逻辑
- 如果当前的值就是要查找的值，那么返回存在(true)
- 如果不是，进行三元运算。如果要查找的值比较大就往右边去找，比较小就往左边
- 如果找到最后了为空，则返回不存在(false)

#### 封装
这毕竟是面向对象的五大原则之一(单一职责)
<p align="center">
<img src="@attachment/CS211-8.png" width="600">
</p>

***
### 数据删除
#### 删除比较麻烦。是三种操作中最麻烦的，分以下三种情况：
- 如果这个节点没有子节点，那么直接删除
> if(current.left == null && current.right == null){return null;}

- 如果这个节点有一个子节点，那么子节点将替代它的位置
> if(current.right == null){return current.left}
if(current.left == null){return current.right}

- 如果这个节点有两个子节点，那么取这个节点的左子树叶子的最大值或者这个节点的右子树叶子的最小值替换本体
> ![](@attachment/Clipboard_2021-03-18-19-44-52.png)
![](@attachment/Clipboard_2021-03-18-19-45-17.png)

最后一种其实也不难，因为左子树的最大值就是左子树叶子节点中最右边的元素。实际上可以嵌套一个Find
#### 代码实现
- 找到要删除的元素(Find)
![](@attachment/Clipboard_2021-03-18-19-53-23.png)
- 上面三种情况

#### 封装
不想多说了，和前面一样的

## BST遍历
### 广度优先遍历
这种一般是用Queue实现的
- Level-Order
- 遍历顺序是逐层遍历
- 时间复杂度：O(n)，n为节点个数
伪代码：
![](@attachment/Clipboard_2021-03-28-17-00-41.png)

#### 代码挺好理解
- 把根节点丢尽queue里
- dequeue根节点，同时把根节点的左右子节点enqueue
- 继续dequeue和enqueue，就完成了广度优先遍历
***
### 深度优先遍历
#### 先序遍历
- Pre-Order
- 遍历顺序是父节点-左子树-右子树
- 时间复杂度：O(n)，n为节点个数
伪代码：
![](@attachment/Clipboard_2021-03-28-16-45-48.png)

***
#### 中序遍历
实际上，这是BST相关算法题里比较常用到的遍历方法，因为**中序遍历BST得到的结果是一个有序的数组/列表**
- In-Order
- 遍历顺序是左子树-父节点-右子树
- 时间复杂度：O(n)，n为节点个数
> **中序遍历结合列表的写法**：
public void inorder(TreeNode root, List <Integer> list) {
&nbsp;&nbsp;&nbsp;&nbsp;if (root == null)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;//遍历左子节点
&nbsp;&nbsp;&nbsp;&nbsp;inorder(root.left, list);
&nbsp;&nbsp;&nbsp;&nbsp;//遍历父节点
&nbsp;&nbsp;&nbsp;&nbsp;list.add(root.val);
&nbsp;&nbsp;&nbsp;&nbsp;//遍历右子节点
&nbsp;&nbsp;&nbsp;&nbsp;inorder(root.right, list);
    }
***
#### 后序遍历
- Post-Order
- 遍历顺序是左子树-右子树-父节点
- 时间复杂度：O(n)，n为节点个数
伪代码：
![](@attachment/Clipboard_2021-03-28-16-53-42.png)

使用迭代的方式进行遍历：利用stack的结构，代码如下
public static void preOrder(TreeNode biTree)
	{//非递归实现
		Stack<TreeNode> stack = new Stack<TreeNode>();
		while(biTree != null || !stack.isEmpty())
		{
			while(biTree != null)
			{
				System.out.println(biTree.value);
				stack.push(biTree);
				biTree = biTree.left;
			}
			if(!stack.isEmpty())
			{
				biTree = stack.pop();
				biTree = biTree.right;
			}
		}
	}
我觉得我是需要一些可视化理解












