---
tags: [大二/CS211算法与数据结构II]
title: 第11章-哈希表
created: '2021-03-16T15:41:03.991Z'
modified: '2021-09-27T02:18:57.699Z'
---

# 第11章-哈希表
## 什么是哈希表
> A hash table is a collection of items which are stored in such a way as to make it easy to find them later.
**哈希表是一组项的集合，这些项的存储方式便于以后查找.key的命名从0开始**
- 有Hash Function(计算Hash Value)
- 得出Hash Value之后，真正的key值为hv%数组的长度
- 有一个结构存放数据，最佳情况是使用键值对组成的哈希表（链表数组）
### 搜索
哈希表搜索的时间复杂度是O(1)，因为每个元素都有对应的key值，直接抓出key值就是对应元素了

## 哈希函数
数经过哈希函数获得哈希值(hash)，随后哈希值%数组长度获得index
一个好的hash function应该具有以下几种功能：
- 容易计算
- 均匀分布
- 减少碰撞

### 余数法
- 拿到需要hash的数x(或者说**key**)，使用hash函数获得哈希值
```
hash = x % 数组长度
h(key) = key % D
```
- hash即x的键(在数组中的index)。值为x本身

### 中间平方法
- 拿到需要hash的数，对其平方
- 取平方完的数中间的数字再次平方
- 重复多次上述操作，直到得到你想要的key。这种情况下得到的key具有极大的随机性（如果初始输入很大的话）
<p align="center">
<img src="@attachment/CS211-1.png" width="600">
</p>

最终得到的键为7307

> 负荷系数(Load Factor)
负荷系数是衡量哈希表的负荷情况的系数，记作λ
当哈希表装满时，λ = 1；当哈希表装了一半时，λ = 0.5
```
       已经填入哈希表的元素个数
λ = ————————————————————————————
             哈希表的大小
```

## 哈希碰撞
由于Hash函数没选好而导致value的key重叠碰撞。遇到这种情况
> 实际上，最简单的观察一个hash function是否会发生碰撞的方法就是看这个函数是否是**单调递增/单调递减**的

有这么几种寻找碰撞的方法：
### 断开链表
- 首先，该hash使用的**数据结构是链表**
- 如果出现冲突，请把另一个元素继续放进来形成一个数组链表
<p align="center">
<img src="@attachment/CS211-2.png" width="400">
</p>

***

### 线性探测
- hash的**结构是数组**
- 当遇到碰撞时，在原本计算得到的key的基础上+1%数组大小
```
(h(key) + 1) % table_size
```
- 如果再遇到，那就在**最开始得到的key上**+2%数组大小
- 相同思想递归
#### 线性探测难题：删除问题
> 当在同一个key处存在相同的碰撞，可能会导致连续的一个范围内都是这个key的线性延伸
此时，当我们删掉了这个线性延伸中间的一部分时，就可能会导致程序认为这个key的延伸已经没有了。请问怎么办呢？

正确做法是使用**tombstone**（墓碑，只是一个比喻）标记该单元格是空的，并且之前被占用过
- 查找时，不要停留在墓碑前，继续寻找
* 需要小心环绕
- 当插入时，请随意替换你遇到的任何墓碑
<p align="center">
<img src="@attachment/CS211-3.png" width="400">
</p>

#### 线性探测的优点
在实践中，线性探测是最快的通用哈希策略之一。
- 低内存开销: 只需要一个数组和一个hash函数
- 极佳的局部性: 当冲突发生时，我们只搜索数组中相邻的位置
- 出色的缓存性能: 这是上述两个因素的结合
#### 线性探测的缺点
- 线性探测在负载系数很高时表现出严重的性能下降
- 碰撞的数量趋向于随着现有碰撞的数量而增长
> 这称为首次分簇(primary clustering)

***

### 平方探测
- hash的**结构是数组**
- 当遇到碰撞时，在原本计算得到的key的基础上+1<sup>2</sup>%数组大小
```
(h(key) + 1^2) % table_size
```
- 如果再遇到，那就在**最开始得到的key上**+2<sup>2</sup>%数组大小
- 相同思想递归
- **为了保证您的平方探测最终将击中每一个可用点，表大小必须满足质数**

***

### 双散列
- 有**两个hash函数**
- hash的**结构是数组**
- 当遇到碰撞时，在原本计算得到的key的基础上+1*h2(value)%数组大小，也就是用上了第二个函数来找另一个key
- 如果再遇到，那就在**最开始得到的key上**+2*h2(value)%数组大小
- 相同思想递归
```
h1(key) + i * h2(key)
```
<p align="center">
<img src="@attachment/CS211-4.png" width="600">
</p>

### 满表扩容
当负荷系数λ逐渐接近1(或者已经大于1/2)，我们就要考虑给哈希表扩容
- 创建更大的表
- 扫描当前的表，移植到新的表里（使用新的hash函数）
- 扩容rehashing的时间复杂度为O(n)，因为一共有n个元素，每个元素hash的时间复杂度为O(1),每个元素插入的时间复杂度为O(1)，一共是O(1)*N+O(N)


















