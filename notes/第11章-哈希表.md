---
tags: [CS211]
title: 第11章-哈希表
created: '2021-03-16T15:41:03.991Z'
modified: '2021-03-17T13:34:40.748Z'
---

# 第11章-哈希表
## 什么是哈希表
> A hash table is a collection of items which are stored in such a way as to make it easy to find them later.
**哈希表是一组项的集合，这些项的存储方式便于以后查找.key的命名从0开始**
- 有Hash Function(计算Hash Value)
- 得出Hash Value之后，真正的key值为hv%数组的长度
- 有一个结构存放数据，最佳情况是使用键值对组成的哈希表（链表数组）
### 搜索
哈希表搜索的时间复杂度是O(1)，因为每个元素都有对应的key值，直接抓出key值就是对应元素了

## 哈希函数
一个好的hash function应该具有以下几种功能：
- 容易计算
- 均匀分布
- 减少碰撞
### 中间平方法
- 拿到需要hash的数，对其平方
- 取平方完的数中间的数字再次平方
- 重复多次上述操作，直到得到你想要的key。这种情况下得到的key具有极大的随机性（如果初始输入很大的话）
<p align="center">
<img src="@attachment/CS211-1.png" width="600">
</p>

## 哈希碰撞
由于Hash函数没选好而导致value的key重叠碰撞。遇到这种情况

> 实际上，最简单的观察一个hash function是否会发生碰撞的方法就是看这个函数是否是**单调递增/单调递减**的

有这么几种寻找碰撞的方法：
### 断开链表
- 首先，该hash使用的数据结构是链表
- 如果出现冲突，请把另一个元素继续放进来形成一个数组链表
<p align="center">
<img src="@attachment/CS211-2.png" width="400">
</p>

***

### 线性探查
- hash的结构是数组
- 当遇到碰撞时，在原本计算得到的key的基础上+1%数组大小
- 如果再遇到，那就在**最开始得到的key上**+2%数组大小
- 相同思想递归
#### 线性探查难题：删除问题
> 当在同一个key处存在相同的碰撞，可能会导致连续的一个范围内都是这个key的线性延伸
此时，当我们删掉了这个线性延伸中间的一部分时，就可能会导致程序认为这个key的延伸已经没有了。请问怎么办呢？

正确做法是使用**tombstone**（墓碑，只是一个比喻）标记该单元格是空的，并且之前被占用过
- 查找时，不要停留在墓碑前，继续寻找
* 需要小心环绕
- 当插入时，请随意替换你遇到的任何墓碑
<p align="center">
<img src="@attachment/CS211-3.png" width="400">
</p>

#### 线性探查的优点
在实践中，线性探测是最快的通用哈希策略之一。
- 低内存开销: 只需要一个数组和一个hash函数
- 极佳的局部性: 当冲突发生时，我们只搜索数组中相邻的位置
- 出色的缓存性能: 这是上述两个因素的结合
#### 线性探查的缺点
- 线性探测在负载系数很高时表现出严重的性能下降
- 碰撞的数量趋向于随着现有碰撞的数量而增长
> 这称为主集群(primary clustering)

***

### 二次探查
- hash的结构是数组
- 当遇到碰撞时，在原本计算得到的key的基础上+1<sup>2</sup>%数组大小
- 如果再遇到，那就在**最开始得到的key上**+2<sup>2</sup>%数组大小
- 相同思想递归
- **为了保证您的二次探测最终将击中每一个可用点，表大小必须满足质数**

***

### 双重hashing
- 有两个hash函数
- hash的结构是数组
- 当遇到碰撞时，在原本计算得到的key的基础上+1*h2(value)%数组大小，也就是用上了第二个函数来找另一个key
- 如果再遇到，那就在**最开始得到的key上**+2*h2(value)%数组大小
- 相同思想递归
<p align="center">
<img src="@attachment/CS211-4.png" width="600">
</p>

### 满表扩容
衡量表格是否满了的参数：λ
**λ = 当前元素个数/表格长度**
当λ逐渐接近1(或者已经大于1/2)，我们就要考虑给哈希表扩容
- 创建更大的表
- 扫描当前的表，移植到新的表里（使用新的hash函数）
- 扩容rehashing的时间复杂度为O(n)，因为一共有n个元素，每个元素hash的时间复杂度为O(1),每个元素插入的时间复杂度为O(1)，一共是O(1)*N+O(N)


















